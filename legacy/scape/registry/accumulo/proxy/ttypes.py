"""
Copyright (2016) Massachusetts Institute of Technology.  Reproduction/Use 
of all or any part of this material shall acknowledge the MIT Lincoln 
Laboratory as the source under the sponsorship of the US Air Force 
Contract No. FA8721-05-C-0002.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

"""
#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class PartialKey:
  ROW = 0
  ROW_COLFAM = 1
  ROW_COLFAM_COLQUAL = 2
  ROW_COLFAM_COLQUAL_COLVIS = 3
  ROW_COLFAM_COLQUAL_COLVIS_TIME = 4
  ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL = 5

  _VALUES_TO_NAMES = {
    0: "ROW",
    1: "ROW_COLFAM",
    2: "ROW_COLFAM_COLQUAL",
    3: "ROW_COLFAM_COLQUAL_COLVIS",
    4: "ROW_COLFAM_COLQUAL_COLVIS_TIME",
    5: "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL",
  }

  _NAMES_TO_VALUES = {
    "ROW": 0,
    "ROW_COLFAM": 1,
    "ROW_COLFAM_COLQUAL": 2,
    "ROW_COLFAM_COLQUAL_COLVIS": 3,
    "ROW_COLFAM_COLQUAL_COLVIS_TIME": 4,
    "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL": 5,
  }

class TablePermission:
  READ = 2
  WRITE = 3
  BULK_IMPORT = 4
  ALTER_TABLE = 5
  GRANT = 6
  DROP_TABLE = 7

  _VALUES_TO_NAMES = {
    2: "READ",
    3: "WRITE",
    4: "BULK_IMPORT",
    5: "ALTER_TABLE",
    6: "GRANT",
    7: "DROP_TABLE",
  }

  _NAMES_TO_VALUES = {
    "READ": 2,
    "WRITE": 3,
    "BULK_IMPORT": 4,
    "ALTER_TABLE": 5,
    "GRANT": 6,
    "DROP_TABLE": 7,
  }

class SystemPermission:
  GRANT = 0
  CREATE_TABLE = 1
  DROP_TABLE = 2
  ALTER_TABLE = 3
  CREATE_USER = 4
  DROP_USER = 5
  ALTER_USER = 6
  SYSTEM = 7

  _VALUES_TO_NAMES = {
    0: "GRANT",
    1: "CREATE_TABLE",
    2: "DROP_TABLE",
    3: "ALTER_TABLE",
    4: "CREATE_USER",
    5: "DROP_USER",
    6: "ALTER_USER",
    7: "SYSTEM",
  }

  _NAMES_TO_VALUES = {
    "GRANT": 0,
    "CREATE_TABLE": 1,
    "DROP_TABLE": 2,
    "ALTER_TABLE": 3,
    "CREATE_USER": 4,
    "DROP_USER": 5,
    "ALTER_USER": 6,
    "SYSTEM": 7,
  }

class ScanType:
  SINGLE = 0
  BATCH = 1

  _VALUES_TO_NAMES = {
    0: "SINGLE",
    1: "BATCH",
  }

  _NAMES_TO_VALUES = {
    "SINGLE": 0,
    "BATCH": 1,
  }

class ScanState:
  IDLE = 0
  RUNNING = 1
  QUEUED = 2

  _VALUES_TO_NAMES = {
    0: "IDLE",
    1: "RUNNING",
    2: "QUEUED",
  }

  _NAMES_TO_VALUES = {
    "IDLE": 0,
    "RUNNING": 1,
    "QUEUED": 2,
  }

class CompactionType:
  MINOR = 0
  MERGE = 1
  MAJOR = 2
  FULL = 3

  _VALUES_TO_NAMES = {
    0: "MINOR",
    1: "MERGE",
    2: "MAJOR",
    3: "FULL",
  }

  _NAMES_TO_VALUES = {
    "MINOR": 0,
    "MERGE": 1,
    "MAJOR": 2,
    "FULL": 3,
  }

class CompactionReason:
  USER = 0
  SYSTEM = 1
  CHOP = 2
  IDLE = 3
  CLOSE = 4

  _VALUES_TO_NAMES = {
    0: "USER",
    1: "SYSTEM",
    2: "CHOP",
    3: "IDLE",
    4: "CLOSE",
  }

  _NAMES_TO_VALUES = {
    "USER": 0,
    "SYSTEM": 1,
    "CHOP": 2,
    "IDLE": 3,
    "CLOSE": 4,
  }

class IteratorScope:
  MINC = 0
  MAJC = 1
  SCAN = 2

  _VALUES_TO_NAMES = {
    0: "MINC",
    1: "MAJC",
    2: "SCAN",
  }

  _NAMES_TO_VALUES = {
    "MINC": 0,
    "MAJC": 1,
    "SCAN": 2,
  }

class TimeType:
  LOGICAL = 0
  MILLIS = 1

  _VALUES_TO_NAMES = {
    0: "LOGICAL",
    1: "MILLIS",
  }

  _NAMES_TO_VALUES = {
    "LOGICAL": 0,
    "MILLIS": 1,
  }


class Key:
  """
  Attributes:
   - row
   - colFamily
   - colQualifier
   - colVisibility
   - timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
    (2, TType.STRING, 'colFamily', None, None, ), # 2
    (3, TType.STRING, 'colQualifier', None, None, ), # 3
    (4, TType.STRING, 'colVisibility', None, None, ), # 4
    (5, TType.I64, 'timestamp', None, 9223372036854775807, ), # 5
  )

  def __init__(self, row=None, colFamily=None, colQualifier=None, colVisibility=None, timestamp=thrift_spec[5][4],):
    self.row = row
    self.colFamily = colFamily
    self.colQualifier = colQualifier
    self.colVisibility = colVisibility
    self.timestamp = timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.colQualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.colVisibility = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Key')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.colFamily is not None:
      oprot.writeFieldBegin('colFamily', TType.STRING, 2)
      oprot.writeString(self.colFamily)
      oprot.writeFieldEnd()
    if self.colQualifier is not None:
      oprot.writeFieldBegin('colQualifier', TType.STRING, 3)
      oprot.writeString(self.colQualifier)
      oprot.writeFieldEnd()
    if self.colVisibility is not None:
      oprot.writeFieldBegin('colVisibility', TType.STRING, 4)
      oprot.writeString(self.colVisibility)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 5)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnUpdate:
  """
  Attributes:
   - colFamily
   - colQualifier
   - colVisibility
   - timestamp
   - value
   - deleteCell
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colFamily', None, None, ), # 1
    (2, TType.STRING, 'colQualifier', None, None, ), # 2
    (3, TType.STRING, 'colVisibility', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRING, 'value', None, None, ), # 5
    (6, TType.BOOL, 'deleteCell', None, None, ), # 6
  )

  def __init__(self, colFamily=None, colQualifier=None, colVisibility=None, timestamp=None, value=None, deleteCell=None,):
    self.colFamily = colFamily
    self.colQualifier = colQualifier
    self.colVisibility = colVisibility
    self.timestamp = timestamp
    self.value = value
    self.deleteCell = deleteCell

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colQualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.colVisibility = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.deleteCell = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ColumnUpdate')
    if self.colFamily is not None:
      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
      oprot.writeString(self.colFamily)
      oprot.writeFieldEnd()
    if self.colQualifier is not None:
      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
      oprot.writeString(self.colQualifier)
      oprot.writeFieldEnd()
    if self.colVisibility is not None:
      oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
      oprot.writeString(self.colVisibility)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 5)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.deleteCell is not None:
      oprot.writeFieldBegin('deleteCell', TType.BOOL, 6)
      oprot.writeBool(self.deleteCell)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeyValue:
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, key=None, value=None,):
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = Key()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeyValue')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanResult:
  """
  Attributes:
   - results
   - more
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'results', (TType.STRUCT,(KeyValue, KeyValue.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'more', None, None, ), # 2
  )

  def __init__(self, results=None, more=None,):
    self.results = results
    self.more = more

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.results = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = KeyValue()
            _elem5.read(iprot)
            self.results.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.more = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanResult')
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.results))
      for iter6 in self.results:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.more is not None:
      oprot.writeFieldBegin('more', TType.BOOL, 2)
      oprot.writeBool(self.more)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Range:
  """
  Attributes:
   - start
   - startInclusive
   - stop
   - stopInclusive
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'start', (Key, Key.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'startInclusive', None, None, ), # 2
    (3, TType.STRUCT, 'stop', (Key, Key.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'stopInclusive', None, None, ), # 4
  )

  def __init__(self, start=None, startInclusive=None, stop=None, stopInclusive=None,):
    self.start = start
    self.startInclusive = startInclusive
    self.stop = stop
    self.stopInclusive = stopInclusive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.start = Key()
          self.start.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.startInclusive = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.stop = Key()
          self.stop.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.stopInclusive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Range')
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRUCT, 1)
      self.start.write(oprot)
      oprot.writeFieldEnd()
    if self.startInclusive is not None:
      oprot.writeFieldBegin('startInclusive', TType.BOOL, 2)
      oprot.writeBool(self.startInclusive)
      oprot.writeFieldEnd()
    if self.stop is not None:
      oprot.writeFieldBegin('stop', TType.STRUCT, 3)
      self.stop.write(oprot)
      oprot.writeFieldEnd()
    if self.stopInclusive is not None:
      oprot.writeFieldBegin('stopInclusive', TType.BOOL, 4)
      oprot.writeBool(self.stopInclusive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanColumn:
  """
  Attributes:
   - colFamily
   - colQualifier
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colFamily', None, None, ), # 1
    (2, TType.STRING, 'colQualifier', None, None, ), # 2
  )

  def __init__(self, colFamily=None, colQualifier=None,):
    self.colFamily = colFamily
    self.colQualifier = colQualifier

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colQualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanColumn')
    if self.colFamily is not None:
      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
      oprot.writeString(self.colFamily)
      oprot.writeFieldEnd()
    if self.colQualifier is not None:
      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
      oprot.writeString(self.colQualifier)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IteratorSetting:
  """
  Attributes:
   - priority
   - name
   - iteratorClass
   - properties
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'priority', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'iteratorClass', None, None, ), # 3
    (4, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, priority=None, name=None, iteratorClass=None, properties=None,):
    self.priority = priority
    self.name = name
    self.iteratorClass = iteratorClass
    self.properties = properties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.iteratorClass = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = iprot.readString();
            self.properties[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IteratorSetting')
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 1)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.iteratorClass is not None:
      oprot.writeFieldBegin('iteratorClass', TType.STRING, 3)
      oprot.writeString(self.iteratorClass)
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter14,viter15 in self.properties.items():
        oprot.writeString(kiter14)
        oprot.writeString(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanOptions:
  """
  Attributes:
   - authorizations
   - range
   - columns
   - iterators
   - bufferSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ), # 2
    (3, TType.LIST, 'columns', (TType.STRUCT,(ScanColumn, ScanColumn.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 4
    (5, TType.I32, 'bufferSize', None, None, ), # 5
  )

  def __init__(self, authorizations=None, range=None, columns=None, iterators=None, bufferSize=None,):
    self.authorizations = authorizations
    self.range = range
    self.columns = columns
    self.iterators = iterators
    self.bufferSize = bufferSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.authorizations = set()
          (_etype19, _size16) = iprot.readSetBegin()
          for _i20 in xrange(_size16):
            _elem21 = iprot.readString();
            self.authorizations.add(_elem21)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.range = Range()
          self.range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.columns = []
          (_etype25, _size22) = iprot.readListBegin()
          for _i26 in xrange(_size22):
            _elem27 = ScanColumn()
            _elem27.read(iprot)
            self.columns.append(_elem27)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.iterators = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = IteratorSetting()
            _elem33.read(iprot)
            self.iterators.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.bufferSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanOptions')
    if self.authorizations is not None:
      oprot.writeFieldBegin('authorizations', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
      for iter34 in self.authorizations:
        oprot.writeString(iter34)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.range is not None:
      oprot.writeFieldBegin('range', TType.STRUCT, 2)
      self.range.write(oprot)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter35 in self.columns:
        iter35.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iterators is not None:
      oprot.writeFieldBegin('iterators', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
      for iter36 in self.iterators:
        iter36.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.bufferSize is not None:
      oprot.writeFieldBegin('bufferSize', TType.I32, 5)
      oprot.writeI32(self.bufferSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchScanOptions:
  """
  Attributes:
   - authorizations
   - ranges
   - columns
   - iterators
   - threads
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'ranges', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'columns', (TType.STRUCT,(ScanColumn, ScanColumn.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 4
    (5, TType.I32, 'threads', None, None, ), # 5
  )

  def __init__(self, authorizations=None, ranges=None, columns=None, iterators=None, threads=None,):
    self.authorizations = authorizations
    self.ranges = ranges
    self.columns = columns
    self.iterators = iterators
    self.threads = threads

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.authorizations = set()
          (_etype40, _size37) = iprot.readSetBegin()
          for _i41 in xrange(_size37):
            _elem42 = iprot.readString();
            self.authorizations.add(_elem42)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ranges = []
          (_etype46, _size43) = iprot.readListBegin()
          for _i47 in xrange(_size43):
            _elem48 = Range()
            _elem48.read(iprot)
            self.ranges.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.columns = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = ScanColumn()
            _elem54.read(iprot)
            self.columns.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.iterators = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = IteratorSetting()
            _elem60.read(iprot)
            self.iterators.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.threads = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchScanOptions')
    if self.authorizations is not None:
      oprot.writeFieldBegin('authorizations', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
      for iter61 in self.authorizations:
        oprot.writeString(iter61)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ranges is not None:
      oprot.writeFieldBegin('ranges', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.ranges))
      for iter62 in self.ranges:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter63 in self.columns:
        iter63.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iterators is not None:
      oprot.writeFieldBegin('iterators', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
      for iter64 in self.iterators:
        iter64.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.threads is not None:
      oprot.writeFieldBegin('threads', TType.I32, 5)
      oprot.writeI32(self.threads)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeyValueAndPeek:
  """
  Attributes:
   - keyValue
   - hasNext
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'keyValue', (KeyValue, KeyValue.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'hasNext', None, None, ), # 2
  )

  def __init__(self, keyValue=None, hasNext=None,):
    self.keyValue = keyValue
    self.hasNext = hasNext

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.keyValue = KeyValue()
          self.keyValue.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.hasNext = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeyValueAndPeek')
    if self.keyValue is not None:
      oprot.writeFieldBegin('keyValue', TType.STRUCT, 1)
      self.keyValue.write(oprot)
      oprot.writeFieldEnd()
    if self.hasNext is not None:
      oprot.writeFieldBegin('hasNext', TType.BOOL, 2)
      oprot.writeBool(self.hasNext)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeyExtent:
  """
  Attributes:
   - tableId
   - endRow
   - prevEndRow
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableId', None, None, ), # 1
    (2, TType.STRING, 'endRow', None, None, ), # 2
    (3, TType.STRING, 'prevEndRow', None, None, ), # 3
  )

  def __init__(self, tableId=None, endRow=None, prevEndRow=None,):
    self.tableId = tableId
    self.endRow = endRow
    self.prevEndRow = prevEndRow

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.endRow = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.prevEndRow = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeyExtent')
    if self.tableId is not None:
      oprot.writeFieldBegin('tableId', TType.STRING, 1)
      oprot.writeString(self.tableId)
      oprot.writeFieldEnd()
    if self.endRow is not None:
      oprot.writeFieldBegin('endRow', TType.STRING, 2)
      oprot.writeString(self.endRow)
      oprot.writeFieldEnd()
    if self.prevEndRow is not None:
      oprot.writeFieldBegin('prevEndRow', TType.STRING, 3)
      oprot.writeString(self.prevEndRow)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Column:
  """
  Attributes:
   - colFamily
   - colQualifier
   - colVisibility
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'colFamily', None, None, ), # 1
    (2, TType.STRING, 'colQualifier', None, None, ), # 2
    (3, TType.STRING, 'colVisibility', None, None, ), # 3
  )

  def __init__(self, colFamily=None, colQualifier=None, colVisibility=None,):
    self.colFamily = colFamily
    self.colQualifier = colQualifier
    self.colVisibility = colVisibility

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.colFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.colQualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.colVisibility = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Column')
    if self.colFamily is not None:
      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
      oprot.writeString(self.colFamily)
      oprot.writeFieldEnd()
    if self.colQualifier is not None:
      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
      oprot.writeString(self.colQualifier)
      oprot.writeFieldEnd()
    if self.colVisibility is not None:
      oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
      oprot.writeString(self.colVisibility)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ActiveScan:
  """
  Attributes:
   - client
   - user
   - table
   - age
   - idleTime
   - type
   - state
   - extent
   - columns
   - iterators
   - authorizations
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'client', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
    (3, TType.STRING, 'table', None, None, ), # 3
    (4, TType.I64, 'age', None, None, ), # 4
    (5, TType.I64, 'idleTime', None, None, ), # 5
    (6, TType.I32, 'type', None, None, ), # 6
    (7, TType.I32, 'state', None, None, ), # 7
    (8, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ), # 8
    (9, TType.LIST, 'columns', (TType.STRUCT,(Column, Column.thrift_spec)), None, ), # 9
    (10, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 10
    (11, TType.LIST, 'authorizations', (TType.STRING,None), None, ), # 11
  )

  def __init__(self, client=None, user=None, table=None, age=None, idleTime=None, type=None, state=None, extent=None, columns=None, iterators=None, authorizations=None,):
    self.client = client
    self.user = user
    self.table = table
    self.age = age
    self.idleTime = idleTime
    self.type = type
    self.state = state
    self.extent = extent
    self.columns = columns
    self.iterators = iterators
    self.authorizations = authorizations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.client = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.age = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.idleTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.extent = KeyExtent()
          self.extent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.columns = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = Column()
            _elem70.read(iprot)
            self.columns.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.iterators = []
          (_etype74, _size71) = iprot.readListBegin()
          for _i75 in xrange(_size71):
            _elem76 = IteratorSetting()
            _elem76.read(iprot)
            self.iterators.append(_elem76)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.authorizations = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString();
            self.authorizations.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ActiveScan')
    if self.client is not None:
      oprot.writeFieldBegin('client', TType.STRING, 1)
      oprot.writeString(self.client)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 3)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.age is not None:
      oprot.writeFieldBegin('age', TType.I64, 4)
      oprot.writeI64(self.age)
      oprot.writeFieldEnd()
    if self.idleTime is not None:
      oprot.writeFieldBegin('idleTime', TType.I64, 5)
      oprot.writeI64(self.idleTime)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 6)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 7)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.extent is not None:
      oprot.writeFieldBegin('extent', TType.STRUCT, 8)
      self.extent.write(oprot)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter83 in self.columns:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.iterators is not None:
      oprot.writeFieldBegin('iterators', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
      for iter84 in self.iterators:
        iter84.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.authorizations is not None:
      oprot.writeFieldBegin('authorizations', TType.LIST, 11)
      oprot.writeListBegin(TType.STRING, len(self.authorizations))
      for iter85 in self.authorizations:
        oprot.writeString(iter85)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ActiveCompaction:
  """
  Attributes:
   - extent
   - age
   - inputFiles
   - outputFile
   - type
   - reason
   - localityGroup
   - entriesRead
   - entriesWritten
   - iterators
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ), # 1
    (2, TType.I64, 'age', None, None, ), # 2
    (3, TType.LIST, 'inputFiles', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'outputFile', None, None, ), # 4
    (5, TType.I32, 'type', None, None, ), # 5
    (6, TType.I32, 'reason', None, None, ), # 6
    (7, TType.STRING, 'localityGroup', None, None, ), # 7
    (8, TType.I64, 'entriesRead', None, None, ), # 8
    (9, TType.I64, 'entriesWritten', None, None, ), # 9
    (10, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 10
  )

  def __init__(self, extent=None, age=None, inputFiles=None, outputFile=None, type=None, reason=None, localityGroup=None, entriesRead=None, entriesWritten=None, iterators=None,):
    self.extent = extent
    self.age = age
    self.inputFiles = inputFiles
    self.outputFile = outputFile
    self.type = type
    self.reason = reason
    self.localityGroup = localityGroup
    self.entriesRead = entriesRead
    self.entriesWritten = entriesWritten
    self.iterators = iterators

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.extent = KeyExtent()
          self.extent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.age = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.inputFiles = []
          (_etype89, _size86) = iprot.readListBegin()
          for _i90 in xrange(_size86):
            _elem91 = iprot.readString();
            self.inputFiles.append(_elem91)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.outputFile = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.reason = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.localityGroup = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.entriesRead = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.entriesWritten = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.iterators = []
          (_etype95, _size92) = iprot.readListBegin()
          for _i96 in xrange(_size92):
            _elem97 = IteratorSetting()
            _elem97.read(iprot)
            self.iterators.append(_elem97)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ActiveCompaction')
    if self.extent is not None:
      oprot.writeFieldBegin('extent', TType.STRUCT, 1)
      self.extent.write(oprot)
      oprot.writeFieldEnd()
    if self.age is not None:
      oprot.writeFieldBegin('age', TType.I64, 2)
      oprot.writeI64(self.age)
      oprot.writeFieldEnd()
    if self.inputFiles is not None:
      oprot.writeFieldBegin('inputFiles', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.inputFiles))
      for iter98 in self.inputFiles:
        oprot.writeString(iter98)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.outputFile is not None:
      oprot.writeFieldBegin('outputFile', TType.STRING, 4)
      oprot.writeString(self.outputFile)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 5)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.I32, 6)
      oprot.writeI32(self.reason)
      oprot.writeFieldEnd()
    if self.localityGroup is not None:
      oprot.writeFieldBegin('localityGroup', TType.STRING, 7)
      oprot.writeString(self.localityGroup)
      oprot.writeFieldEnd()
    if self.entriesRead is not None:
      oprot.writeFieldBegin('entriesRead', TType.I64, 8)
      oprot.writeI64(self.entriesRead)
      oprot.writeFieldEnd()
    if self.entriesWritten is not None:
      oprot.writeFieldBegin('entriesWritten', TType.I64, 9)
      oprot.writeI64(self.entriesWritten)
      oprot.writeFieldEnd()
    if self.iterators is not None:
      oprot.writeFieldBegin('iterators', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
      for iter99 in self.iterators:
        iter99.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WriterOptions:
  """
  Attributes:
   - maxMemory
   - latencyMs
   - timeoutMs
   - threads
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'maxMemory', None, None, ), # 1
    (2, TType.I64, 'latencyMs', None, None, ), # 2
    (3, TType.I64, 'timeoutMs', None, None, ), # 3
    (4, TType.I32, 'threads', None, None, ), # 4
  )

  def __init__(self, maxMemory=None, latencyMs=None, timeoutMs=None, threads=None,):
    self.maxMemory = maxMemory
    self.latencyMs = latencyMs
    self.timeoutMs = timeoutMs
    self.threads = threads

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.maxMemory = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.latencyMs = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timeoutMs = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.threads = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WriterOptions')
    if self.maxMemory is not None:
      oprot.writeFieldBegin('maxMemory', TType.I64, 1)
      oprot.writeI64(self.maxMemory)
      oprot.writeFieldEnd()
    if self.latencyMs is not None:
      oprot.writeFieldBegin('latencyMs', TType.I64, 2)
      oprot.writeI64(self.latencyMs)
      oprot.writeFieldEnd()
    if self.timeoutMs is not None:
      oprot.writeFieldBegin('timeoutMs', TType.I64, 3)
      oprot.writeI64(self.timeoutMs)
      oprot.writeFieldEnd()
    if self.threads is not None:
      oprot.writeFieldBegin('threads', TType.I32, 4)
      oprot.writeI32(self.threads)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownScanner(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownScanner')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnknownWriter(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnknownWriter')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoMoreEntriesException(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoMoreEntriesException')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccumuloException(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccumuloException')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccumuloSecurityException(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccumuloSecurityException')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableNotFoundException(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableNotFoundException')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableExistsException(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableExistsException')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MutationsRejectedException(TException):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MutationsRejectedException')
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
